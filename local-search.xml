<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM &amp; JUC 基础课程（主讲：周阳）</title>
    <link href="/2020/07/09/JVM&amp;JUC%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%BB%E8%AE%B2%EF%BC%9A%E5%91%A8%E9%98%B3%EF%BC%89/"/>
    <url>/2020/07/09/JVM&amp;JUC%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%BB%E8%AE%B2%EF%BC%9A%E5%91%A8%E9%98%B3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>##多线程知识及应用</p><p>###Lesson 001 SaleTicket案例</p><pre><font face="黑体" font size = 3>题目：3个售票员卖出30张票<br/>要求：编写企业级的多线程代码<br/></pre><pre><font face = "黑体" font size = 3>解题思路：<br/>1.在高内聚低耦合下，线程操作资源类<br/>2.加锁，否则无法同步</pre><pre><font face = "黑体" font size = 3>问题一：解释进程和线程<br/>答：进程是电脑后台运行的程序，线程是轻量级的进程。<br/>问题二：举一个日常用到的软件，用到进程和线程的例子<br/>答：QQ.exe是QQ的一个进程，用同一个QQ分别文字聊天、视频聊天（线程）同属于一个进程。<br/>问题三：解释并发和并行<br/>答：并发是多个线程同一时间争抢同一资源。比如同一时间抢票、秒杀。并行是多个线程同时操作资源，比如泡面。<br/>问题四：接口能不能new<br/>答：接口是特殊的类，可以new。但如果new成匿名内部类，就需要把方法都实现一遍，挺麻烦，所以有了多态，左边为接口，右边为实现类。<br/>问题五：多线程有哪几种状态<br/>答：五种。① 新建 new ② 就绪 runnable ③ 阻塞 block ④ 死等 waiting ⑤ 过时不候 timed-waiting</pre><pre><font face = "黑体" font size = 3>注意：线程start之后，绝不是立刻启动，多线程的调动和底层的系统和CPU有关。<br/></pre><br/>---<h3 id="Lesson-002-LambdaExpress"><a href="#Lesson-002-LambdaExpress" class="headerlink" title="Lesson 002 LambdaExpress"></a>Lesson 002 LambdaExpress</h3><pre><font face = "黑体" font size = 3>知识点一：Lambda表达式<br/>为解决匿名内部类代码冗余现象（不然要重写接口的方法），拷贝小括号、写死右箭头、落地大括号。<br/>知识点二：@FunctionalInterface<br/>该注释用于检查该接口是否为函数式接口。函数式接口一般只有一个输出，类似于函数f(x) = y。<br/>定义一个接口，其中只有方法声明，没有方法实现（java8之后允许有部分实现）<br/>接口中有且只有一个声明方法，就是函数式接口。<br/>知识点三：default<br/>在函数式接口中，可定义default方法，并且可定义多个。<br/>知识点四：static<br/>在函数式接口中，可定义static方法，并且可定义多个。<br/></pre><br>---<h3 id="Lesson-004-集合类不安全"><a href="#Lesson-004-集合类不安全" class="headerlink" title="Lesson 004 集合类不安全"></a>Lesson 004 集合类不安全</h3><table><thead><tr><th align="center">接口</th><th align="center">List</th><th align="center">Set</th><th align="center">Map</th></tr></thead><tbody><tr><td align="center">类</td><td align="center">ArrayList</td><td align="center">HashSet</td><td align="center">HashMap</td></tr><tr><td align="center">解决</td><td align="center">CopyOnWriteArrayList</td><td align="center">CopyOnWriteArraySet</td><td align="center">ConcurrentHashMap</td></tr><tr><td align="center">以上三种集合类都不安全。<br/></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">原因：多线程争抢同一资源类，没有加锁导致的。</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">故障现象：java.util.ConcurrentModificationException(并发修改异常)</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><pre><font face = "黑体" font size = 3>问题一：当我new了一个ArrayList,底层实际new了一个什么?<br/>答：ArrayList数据库为数组，数组元素为Object<br/>问题二：ArrayList的默认初始长度是多少？<br/>答：初始化一个长度为10的Object数组。HashMap的初始长度为16。<br/>问题三：ArrayList扩容多少？如何扩容？<br/>答：扩大一半：10 -> 15 -> 15 + [15 / 2] = 22。搬家过程：Array.copy()。HashMap扩大一倍。<br/>问题四：ArrayList线程安全吗？<br/>答：不安全。<br/>问题五：写一个ArrayList、HashMap、HashSet线程不安全的代码。<br/>    public static void main(String[] args) {        //List a = new ArrayList();                     // ArrayList线程不安全（效率第一）        List<String> a = new CopyOnWriteArrayList<>();        // 30个线程同时操作一个ArrayList        for (int i = 0; i <= 30; i++) {            new Thread(() -> {                a.add(UUID.randomUUID().toString().substring(0,8));                System.out.println(a);            }, String.valueOf(i)).start();        }    }    public static void main(String[] args) {        //Set a = new HashSet();                     // HashSet()线程不安全        Set<String> a = new CopyOnWriteArraySet<>();        // 30个线程同时操作一个ArrayList        for (int i = 0; i <= 30; i++) {            new Thread(() -> {                a.add(UUID.randomUUID().toString().substring(0,8));                System.out.println(a);            }, String.valueOf(i)).start();        }    }        public static void main(String[] args) {        // Map<String, String> map = new HashMap<>(); // HashMap线程也不安全        Map<String, String> map = new ConcurrentHashMap<>();        for (int i = 0; i <= 30; i++) {            new Thread(() -> {                map.put(UUID.randomUUID().toString().substring(0,2), UUID.randomUUID().toString().substring(0, 8));                System.out.println(map);            }, String.valueOf(i).toString()).start();        }    }问题六：Collection和Collections的区别？<br/>答：前者为接口(集合类的一个顶级接口)，后者为集合接口的包装类（工具类、帮助类），此类不能实例化，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。<br/>问题七：HashSet的底层结构？<br/>答：HashMap。<br/>问题八：HashSet在add操作时，只有一个参数，而HashMap在put()操作时却加入两个参数，一个是key，一个是value，它的底层结构真的是HashMap吗？<br/>答：真的是，public boolean add(E e){    return map.put(e, PRESENT) == null;    } # 加了一个Object类（PRESENT）作为value<br/>问题九：四大函数接口是什么？<br/>答：1.提供者（supplier）：不接受参数，但提供返回值(getter())    2.消费者（consumer）：接收一个参数，无返回值(foreach)    3.函数（function）：接收函数，输出结果    4.断言型（predicate）：用于判断操作，返回Boolean</pre><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><h3 id="lesson-006-八锁"><a href="#lesson-006-八锁" class="headerlink" title="lesson 006 八锁"></a>lesson 006 八锁</h3><pre><font face = "黑体" font size = 3>只要在同资源类中，不管有几个synchronized方法，只要一个线程先访问了资源类里的任一synchronized方法，那么它锁的是整个资源类，锁了这个对象this（**对象锁**），被锁定后，其他线程不能进入当前对象的synchronized方法。**某一时刻内，只有唯一线程访问对象的synchronized方法。<br/>**加个普通方法后，发现与同步锁无关。<br/>换成两个对象之后，就不是一把锁了。<br/>static修饰的方法，属于整个类，而非某个对象，static锁的是“**全局锁**”。<br/>synchronized同步的基础：java中的每个对象都可作为锁。① 对于普通同步方法，锁是当前对象this② 对于同步方法块，锁是synchronized括号里的配置对象。③ 对于静态同步方法类，锁是当前Class对象。<br/>当一个线程试图访问同步代码块时，它必须得到锁，退出或抛出异常时，要释放锁。即，若一个对象的非静态同步方法获取锁，该实例对象的其他非静态同步方法要等锁释放后，才能获取锁。但**别的对象的非静态同步方法，因为不是同一把锁，所以不必等待。**<br/>所有静态同步方法用的也是同一把锁——类对象本身。两把锁是不同的对象，故静态同步方法与非静态同步方法**无竞态条件**。但某静态同步方法获取锁后，其他静态同步方法要等待释放。</pre><h3 id="lesson-014-生产者消费者"><a href="#lesson-014-生产者消费者" class="headerlink" title="lesson 014 生产者消费者"></a>lesson 014 生产者消费者</h3>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划之二叉搜索树</title>
    <link href="/2020/07/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/07/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划之二叉搜索树"><a href="#动态规划之二叉搜索树" class="headerlink" title="动态规划之二叉搜索树"></a>动态规划之二叉搜索树</h1><hr><p>###题目：96. 不同的二叉搜索树</p><pre><font face="黑体" font size = 3>给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？示例:输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树:   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</pre><p>解题思路：<br>设G(n)为n个节点组成的二叉搜索树的种类数。设f(i)为以i为根节点的二叉树的数量。</p><p>由二叉搜索树的特性可知，这棵树的左子树的结点序号为[1,2,3,…,i-1],一共i-1个。右子树的结点序号为[i+1,i+2,..,n],一共n-i个。</p><p>所以左子树的一共有G(i-1)种，右子树有G(n-i)种。由排列组合原理可知，以i为根节点的二叉树数量f(i)=G(i-1)*G(n-i)</p><p>因此状态转移方程为：</p><p>G(n) = f(1)+f(2)+f(3)+…+f(n) = G(0)*G(n-1) + G(1)*G(n-1) +…+ G(n-1)*G(0)</p><p>代码如下：</p><pre><font face="黑体" font size = 3>class Solution {    public int numTrees(int n) {        int[] memo = new int[n + 1];            // 创建一个备忘录        memo[0] = 1;                            // 边界条件        memo[1] = 1;        for (int i = 2; i <= n; i++) {          // 每次循环都向memo填入一个数字            int res = 0;                        // 用于存储累加结果            for(int j = 0; j <= i - 1; j++){    // 计算memo结果                res += memo[j] * memo[i - j - 1];            }            memo[i] = res;        }        return memo[n];    }}</pre><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/07/09/hello-world/"/>
    <url>/2020/07/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
