<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态规划之博弈问题</title>
    <link href="/2020/07/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>题目：1025. 除数博弈</strong><br>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p><p>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：<br>选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。用 N - x 替换黑板上的数字 N 。</p><p>如果玩家无法执行这些操作，就会输掉游戏。</p><p>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。</p><pre><font face="黑体" font size="3">示例 1：输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。示例 2：输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。提示：    1 <= n <="1000" pre><p><strong>解题思路：</strong></p><p>首先可以有一个dp数组辅助分析。dp[i]表示N = i时，游戏的结果。最终的输出是dp[N]</p><p>随着分析，我们很快会发现游戏结果是固定的。</p><p>若N为奇数，则奇数的因子不会有偶数，所以奇数的因子只有奇数。故x一定为奇数，设N - x = t，t一定为偶数。<br>则可以查找dp[t]，结果和dp[t]的结果相反。</p><p>这是什么意思呢？如果dp[t]是true，则dp[N]为false。如果dp[t]是false，则dp[N]为true。</p><p>为什么会这样？因为当Alice拿到N这个数字，选了x之后，就轮到Bob拿到t，在t上继续游戏，但是dp[t]记录的是<br>Alice拿到t之后的输赢，也就是先手拿到t的输赢，所以如果Bob拿到t之后能赢，意味着Alice拿到N是输的。</p><p>这就是前面说的游戏的结果固定。</p><p>若N为偶数：</p><p>N = 2时，已知dp[2] = true。</p><p>N = 4时，4的可选因数有1,2。Alice要想赢，则可以查表，<br>dp[3] = false 和 dp[2] = true，如前所述，Alice的输赢和查表的结果相反，那么Alice一定会选择1。<br>所以dp[4] = true。</p><p>N = 6时，6的可选因数有1,2,3。dp[5] = false,dp[4] = true,dp[3] = false。Alice想要赢，则一定会选择<br>1，所以dp[6] = true。</p><p>发现什么没有？<br>dp[奇数]为dp[偶数]取反。而当N为偶数的时候，可以总取1，由于此时dp[N - 1]总为false，Alice一定会赢。</p><p>也就是说N为偶数一定赢，N为奇数一定输。</p><p>代码如下：</p><pre><font face="黑体" font size="3">class Solution {    public boolean divisorGame(int N) {        return N % 2 == 0;    }}</font></pre></=></font></pre>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode刷题</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划之最大正方形</title>
    <link href="/2020/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2020/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>题目：221. 最大正方形</strong></p><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><pre><font face="黑体" font size="3">示例:输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4</font></pre><p><strong>解题思路：</strong></p><p>状态转移方程为dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);</p><p>代码如下：</p><pre><font face="黑体" font size="3">class Solution {    public int maximalSquare(char[][] matrix) {        /**        dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为:         dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);        **/        int m = matrix.length;        if(m < 1) return 0;        int n = matrix[0].length;        int max = 0;        int[][] dp = new int[m+1][n+1];        for(int i = 1; i <= m; ++i) { for(int j="1;" <="n;" ++j) if(matrix[i-1][j-1]="=" '1') dp[i][j]="1" + math.min(dp[i-1][j-1], math.min(dp[i-1][j], dp[i][j-1])); max="Math.max(max," dp[i][j]); } return max*max; pre><hr><p><strong>题目：1139. 最大的以 1 为边界的正方形</strong></p><p>给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。</p><pre><font face="黑体" font size="3">示例 1：输入：grid = [[1,1,1],[1,0,1],[1,1,1]]输出：9示例 2：输入：grid = [[1,1,0,0]]输出：1</font></pre><p><strong>解题思路：</strong></p><p>从经验来看，我们应该会列和grid等大，或者大一圈的表格，这个表格就是dp数组了。<br>根据grid在表格里填数字，当表格填满，就可以从表格中得到最大正方形的面积。表格里应该填写什么数字？</p><p>首先题目要求以1为边的正方形，可以分别计算横向和纵向边最长能有多长。看图：</p><p><img src="/2020/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/dp1.png" srcset="/img/loading.gif" alt></p><p>红色的是纵向组成的边，蓝色的是横向组成的边（长度为1的我没画，要不然看着乱糟糟）。所以可以创建两个数组，<br>一个left记录横线最长多长，另一个up记录纵线最长多长。那有了两个数组，怎么才能看能不能形成方形呢？不如<br>来找找方形数组的特点：</p><p><img src="/2020/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/dp2.png" srcset="/img/loading.gif" alt></p><p>left[i][j] = 到grid[i][j]为止，横向的边有多长。<br>即如果 grid[i][j] = 1，则 left[i][j] = left[i][j - 1] + 1</p><p>up[i][j] = 到grid[i][j]为止，纵向的边有多长。<br>即如果 grid[i][j] = 1，则 up[i][j] = up[i - 1][j] + 1</p><p>这两个数组有什么关系呢？</p><p>找到垂直的两条，正方形边的最大可能长度为min(left[i][j], up[i][j])。(为什么有min之后补充)可以找到最大的数5。</p><p><img src="/2020/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/dp3.png" srcset="/img/loading.gif" alt></p><pre><font face="黑体" font size="3">问：min(left[i][j], up[i][j]) = 5 能证明grid里正方形的最大边长为5吗？答：不能。</font></pre><p>min(left[i][j], up[i][j]) = 5 只能证明下图中的划线部分是全一的：<br>(因为left[i][j] = 5，说明下边存在而且长度为5。up[i][j] = 5，说明右边存在且长度为5)</p><p><img src="/2020/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/dp4.png" srcset="/img/loading.gif" alt></p><p>如果你不能理解，为什么这不能表示上边和左边不是全一。我们来举个反例：</p><p>下图中有 min(left[i][j], up[i][j]) = 5，但是上边和左边长度不到5，构不成正方形。只有下边和右边长度达标了。 </p><p><img src="/2020/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/dp5.png" srcset="/img/loading.gif" alt></p><p>综上，我们已经为正方形找好了两条边，分别为右边和下边。现在还需要核实上边和左边是否为全一。怎么核实？还是从left数组<br>和up数组找答案呗。</p><p>要求上边全为1，查看left圈橘色的数字。因为上边是横向，left数组的该位置记录了这一行的横线的长度，如果是5我们就放心了。</p><p>要求左边全为1，查看up圈橘色的数字。因为左边为纵向，up数组的该位置记录了这一列到该位置的纵线的长度，如果是5那不就正<br>好组成正方形了吗！</p><p>你看，我们已经成功找到了一个边长为5的正方形了。</p><p><img src="/2020/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/dp6.png" srcset="/img/loading.gif" alt></p><p>上面讲了核实上边和左边的方法，回头看看方才的反例，看能不能检测出那不是个长度为5的方形。如图：</p><p>该位置的两个数都是3，不够和下边以及右边凑成方形。</p><p><img src="/2020/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/dp7.png" srcset="/img/loading.gif" alt></p><p>如此看来，组成一条长为5的方形是不可能的了。那应该直接放弃这两条边了吗？慢着，再考虑考虑，万一还能组成长度为3的方形呢<br>？</p><p>首先下边和右边已经确定长度为5了，我们可以挨个核实上边和左边，看能不能组成小一点的正方形。</p><p>“挨个”的意思就是，先检查蓝色的一圈，看上边和左边长度是否为5。没到5的话，再检查红色的一圈，看上边和左边的长度是否为4。<br>没到4的话，检查绿色的一圈，看上边和左边长度是否为3。没到4的话，再检查紫色的一圈，看长度是否为2。没到2的话，再检查黄的这一圈。</p><p>至于怎么检查，就跟前面所述的方法一样。</p><p><img src="/2020/07/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/dp8.png" srcset="/img/loading.gif" alt></p><p>该说的好像都说完了，上代码 <del>~</del></p><pre><font face="黑体" font size="3">class Solution {    public int largest1BorderedSquare(int[][] grid) {        int res = 0;        int[][] up = new int[grid.length + 1][grid[0].length + 1];        int[][] left = new int[grid.length + 1][grid[0].length + 1];        for(int i = 0; i < grid.length; i++){            for(int j = 0; j < grid[0].length; j++){                if(grid[i][j] == 1){                    up[i + 1][j + 1] = up[i][j + 1] + 1;                                            left[i + 1][j + 1] = left[i + 1][j] + 1;                                        int min = Math.min(up[i + 1][j + 1], left[i + 1][j + 1]);   // 先确定边的最大可能长度                    for(int k = min; k >= 1; k--){                        if(left[i + 1 - k + 1][j + 1] >= k && up[i + 1][j + 1 - k + 1] >= k){                            res = Math.max(res, k);                            break;                        }                    }                }            }        }        return res * res;    }}</font></pre><p>另外，可以把两个数组一个left和up数组整合到dp数组中，简洁一些。</p><pre><font face="黑体" font size="3">class Solution {    public int largest1BorderedSquare(int[][] grid) {        int res = 0;        int[][][] dp = new int[grid.length + 1][grid[0].length + 1][2];        for(int i = 0; i < grid.length; i++){            for(int j = 0; j < grid[0].length; j++){                if(grid[i][j] == 1){                    dp[i + 1][j + 1][0] = dp[i][j + 1][0] + 1;                                            dp[i + 1][j + 1][1] = dp[i + 1][j][1] + 1;                                        int min = Math.min(dp[i + 1][j + 1][0], dp[i + 1][j + 1][1]);   // 先确定边的最大可能长度                    for(int k = min; k >= 1; k--){                        if(dp[i + 1 - k + 1][j + 1][1] >= k && dp[i + 1][j + 1 - k + 1][0] >= k){                            res = Math.max(res, k);                            break;                        }                    }                }            }        }        return res * res;    }}</font></pre><hr><p><strong>题目：1277. 统计全为 1 的正方形子矩阵</strong></p><p>给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的<br>个数。</p><pre><font face="黑体" font size="3">示例 1：输入：matrix =[  [0,1,1,1],  [1,1,1,1],  [0,1,1,1]]输出：15解释： 边长为 1 的正方形有 10 个。边长为 2 的正方形有 4 个。边长为 3 的正方形有 1 个。正方形的总数 = 10 + 4 + 1 = 15.示例 2：输入：matrix = [  [1,0,1],  [1,1,0],  [1,1,0]]输出：7解释：边长为 1 的正方形有 6 个。 边长为 2 的正方形有 1 个。正方形的总数 = 6 + 1 = 7.</font></pre><p><strong>解题思路：</strong><br>解法和题目221基本一致。</p><pre><font face="黑体" font size="3">class Solution {    public int countSquares(int[][] matrix) {        int m = matrix.length;        int n = matrix[0].length;        if(m == 0 || n == 0 || matrix == null)    return 0;        int[][] dp = new int[m + 1][n + 1];        int res = 0;        for(int i = 1; i <= m; i++){ for(int j="1;" <="n;" j++){ if(matrix[i - 1][j 1]="=" 1){ dp[i][j]="Math.min(Math.min(dp[i" 1][j], dp[i 1]), dp[i][j 1]) + 1; res } return res; pre></=></font></pre></=></font></pre>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode刷题</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络之ARP协议</title>
    <link href="/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>这篇文章谈谈ARP协议，在开始之前，咱们先热热身：</p><pre><font face="黑体" font size = 3>OSI七层模型中，ARP是属于哪一层的协议？A. 应用层B. 传输层C. 网络层D. 数据链路层</pre><pre><font face="黑体" font size = 3>解析：在OSI模型（七层）中，ARP协议属于数据链路层。在TCP/IP模型（五层）中，ARP协议属于网络层。选D。</pre><p>在讲ARP协议之前先来复习两个概念：<strong>IP地址</strong>和<strong>MAC地址</strong>。</p><p><strong>一、IP地址</strong><br>IP地址就是要在茫茫网络中找到特定电脑。既然网络由路由器和主机连接起来，那么这个IP地址就要能明确，哪个网络？哪台主机？<br>它有两个版本，大家都不陌生，分别为IPv4和IPv6。</p><p><strong>1.IPv4地址</strong></p><p>IP编址的历史阶段有三个，分别代表三种编址方式：</p><p>(1) 分类的IP地址</p><p>(2) 子网的划分</p><p>(3) 构成超网（无分类编址方法）</p><p>详细解释一下：</p><p>(1) 分类的IP地址</p><p>IP地址：计算机的身份证号，全世界唯一的32位/4字节的标识符，用于标识路由器主机的接口。</p><p><strong>IP地址:={&lt;网络号&gt;,&lt;主机号&gt;}</strong>。</p><p>注意：并不是一个IP地址标识一个主机，一个主机可以有很多接口。有线上网，就是有线接口。无线上网，就是无线接口。而路由器<br>也不单只有一个接口，一个路由器可以连很多个主机，也可以连很多的路由器。即，<strong>一个路由器有很多个接口，每个接口都会分配<br>一个唯一的IP地址。</strong></p><pre><font face="黑体" font size = 3>例如：某电脑的IP地址为11011111  00000001  00000001  00000001 = 223.1.1.1 (点分十进制表示)这前面的 11011111 = 223 为网络号，后面的 00000001  00000001  00000001 = 1.1.1 为主机号。</pre><p>看下面这张图片：<br>图中有六个网络，橘色的部分分别为同一路由器接口所连接。</p><p>左边的局域网为LAN1用222.1.3.0表示（同一网络的网络号相同，主机号各不相同）。</p><p>上方的局域网为LAN2用222.1.1.0表示。</p><p>右下角的局域网为LAN3用222.1.2.0表示，该网络中有一个网桥，已知网桥无法分割网段，即该网络只是一个局域网。</p><p>且从图中可看出，一个路由器就有三个IP地址，每个接口一个地址。</p><p>三个绿色区域为无编号网络（无名网络）</p><p><img src="t.png" srcset="/img/loading.gif" alt=""></p><p>下面是分类的IP地址：</p><p>IP地址被分为了五类：ABCDE。它们的不同就在于，网络号分配的字节数不同。<br><img src="t1.png" srcset="/img/loading.gif" alt=""></p><p>注意：并不是所有的IP地址都可以使用，会有一些特殊的IP地址，不能随便使用。</p><p><img src="t2.png" srcset="/img/loading.gif" alt=""></p><p>除了特殊IP地址，还有私有IP地址，用于本网，专用网。路由器对目的地址是私有IP地址的数据报一律不进行转发。<br>（放在外网或因特网中无效）<strong>私有IP地址</strong>如下：</p><table><thead><tr><th align="center">地址类别</th><th align="center">地址范围</th><th align="center">网段个数</th></tr></thead><tbody><tr><td align="center">A类</td><td align="center">10.0.0.0 - 10.255.255.255</td><td align="center">1</td></tr><tr><td align="center">B类</td><td align="center">172.16.0.0 - 172.31.255.255</td><td align="center">16</td></tr><tr><td align="center">C类</td><td align="center">192.168.0.0 - 192.168.255.255</td><td align="center">256</td></tr></tbody></table><p>私有IP地址如何能被因特网识别？</p><p>需要<strong>网络地址转换NAT</strong>(Network Address Translation)技术：在<strong>专用网</strong>连接到<strong>因特网</strong>的路由器上安装NAT软件，安装了<br>软件的路由器叫<strong>NAT路由器</strong>，他至少有一个有效地<strong>外部全球IP地址</strong>。</p><p>可以将NAT技术理解为翻译官，将内网IP地址翻译为外网IP地址。或者可以理解为，全村只有一台电话在村长的家里，<br>村民要打电话都要去村长家。有电话打进村，也都需要村长喊人来接。</p><p><img src="t3.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划之二叉搜索树</title>
    <link href="/2020/07/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/07/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>题目：96. 不同的二叉搜索树</strong></p><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><pre><font face="黑体" font size = 3>示例:输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树:   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</pre><p><strong>解题思路：</strong></p><p>设G(n)为n个节点组成的二叉搜索树的种类数。设f(i)为以i为根节点的二叉树的数量。</p><p>由二叉搜索树的特性可知，这棵树的左子树的结点序号为[1,2,3,…,i-1],一共i-1个。右子树的结点序号为[i+1,i+2,..,n],一共n-i个。</p><p>所以左子树的一共有G(i-1)种，右子树有G(n-i)种。由排列组合原理可知，以i为根节点的二叉树数量f(i)=G(i-1)*G(n-i)</p><p>因此状态转移方程为：</p><p>G(n) = f(1)+f(2)+f(3)+…+f(n) = G(0)*G(n-1) + G(1)*G(n-1) +…+ G(n-1)*G(0)</p><p><strong>算法复杂度分析：</strong></p><p>首先，看代码有两层循环。外层循环是 n 次，内层循环是 i 次，也就是 2 + 3 + … + n,即时间复杂度为O(n*n)。</p><p>其次，我们需要一个长度为 n 的数组，来存放计算结果，所以空间复杂度为 O(n).</p><p><strong>代码如下：</strong></p><pre><font face="黑体" font size = 3>class Solution {    public int numTrees(int n) {        int[] memo = new int[n + 1];            // 创建一个备忘录        memo[0] = 1;                            // 边界条件        memo[1] = 1;        for (int i = 2; i <= n; i++) {          // 每次循环都向memo填入一个数字            int res = 0;                        // 用于存储累加结果            for(int j = 0; j <= i - 1; j++){    // 计算memo结果                res += memo[j] * memo[i - j - 1];            }            memo[i] = res;        }        return memo[n];    }}</pre><hr><p><strong>题目：95. 不同的二叉搜索树 II</strong></p><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p><pre><font face="黑体" font size = 3>示例：输入：3输出：[  [1,null,3,2],  [3,2,null,1],  [3,1,null,null,2],  [2,1,3],  [1,null,2,null,3]]解释：以上的输出对应以下 5 种不同结构的二叉搜索树：   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3</pre><p><strong>解题思路：</strong></p><p>这题要求我们构造二叉搜索树，考虑递归构造。树可以以1…n为根节点构造，所以需要遍历。<br>而以i为根节点的树，它的左子树是由[1,…,i-1]构成，右子树是由[i+1,…,n]构成，所以我们可以<br>start和end两个下标，分别表示构建一棵树的最小结点和最大结点。我们分别以[1,…,i-1]构建完左子<br>树集合和[i+1,…,n]右子树集合之后，就可以在两个集合中挑选出左右子树做拼接了。（两重for循环）</p><p><strong>算法复杂度分析：</strong></p><p>首先，生成一棵二叉搜索树的时间复杂度为O(n),(因为在每次调用构造二叉搜索树的函数时，都相当于确<br>定一个“根节点”，即确定一个结点的位置)。而对于 n 个点生成的二叉搜索树数量等价于数学上第 n 个<br>「卡特兰数」，用 G(n) 表示。所以时间复杂度为O(n * G(n)).</p><p>其次，n个节点构成的树的空间复杂度为O(n),一共有G(n)棵树，所以空间复杂度也是O(n * G(n))。</p><p><strong>代码如下：</strong></p><pre><font face="黑体" font size = 3>class Solution {    public List<TreeNode> generateTrees(int n) {        if(n == 0)  return new LinkedList<TreeNode>();          // n=0时返回一个空列表即可        return generateTrees(1, n);                             // 可用结点范围是1-n    }    public List<TreeNode> generateTrees(int start, int end){        List<TreeNode> allTrees = new LinkedList<TreeNode>();        if(start > end){            allTrees.add(null);            return allTrees;        }        // 从start到end每一个都可以成为一个根节点        for(int i = start; i <= end; i++){            // 构建左子树            List<TreeNode> leftTree = generateTrees(start, i - 1);            // 构建右子树            List<TreeNode> rightTree = generateTrees(i + 1, end);            // 将左子树和右子树拼接起来            for(TreeNode left : leftTree){                for(TreeNode right : rightTree){                    TreeNode tree = new TreeNode(i);            // 根节点是i                    tree.left = left;                    tree.right = right;                    allTrees.add(tree);                         // 构造完一棵树后加入链表                }            }        }        return allTrees;    }}</pre>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode刷题</tag>
      
      <tag>动态规划</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM &amp; JUC 基础课程（主讲：周阳）</title>
    <link href="/2020/07/09/JVM&amp;JUC%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%BB%E8%AE%B2%EF%BC%9A%E5%91%A8%E9%98%B3%EF%BC%89/"/>
    <url>/2020/07/09/JVM&amp;JUC%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%EF%BC%88%E4%B8%BB%E8%AE%B2%EF%BC%9A%E5%91%A8%E9%98%B3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>##多线程知识及应用</p><p>###Lesson 001 SaleTicket案例</p><pre><font face="黑体" font size = 3>题目：3个售票员卖出30张票<br/>要求：编写企业级的多线程代码<br/></pre><pre><font face = "黑体" font size = 3>解题思路：<br/>1.在高内聚低耦合下，线程操作资源类<br/>2.加锁，否则无法同步</pre><pre><font face = "黑体" font size = 3>问题一：解释进程和线程<br/>答：进程是电脑后台运行的程序，线程是轻量级的进程。<br/>问题二：举一个日常用到的软件，用到进程和线程的例子<br/>答：QQ.exe是QQ的一个进程，用同一个QQ分别文字聊天、视频聊天（线程）同属于一个进程。<br/>问题三：解释并发和并行<br/>答：并发是多个线程同一时间争抢同一资源。比如同一时间抢票、秒杀。并行是多个线程同时操作资源，比如泡面。<br/>问题四：接口能不能new<br/>答：接口是特殊的类，可以new。但如果new成匿名内部类，就需要把方法都实现一遍，挺麻烦，所以有了多态，左边为接口，右边为实现类。<br/>问题五：多线程有哪几种状态<br/>答：五种。① 新建 new ② 就绪 runnable ③ 阻塞 block ④ 死等 waiting ⑤ 过时不候 timed-waiting</pre><pre><font face = "黑体" font size = 3>注意：线程start之后，绝不是立刻启动，多线程的调动和底层的系统和CPU有关。<br/></pre><br/>---<h3 id="Lesson-002-LambdaExpress"><a href="#Lesson-002-LambdaExpress" class="headerlink" title="Lesson 002 LambdaExpress"></a>Lesson 002 LambdaExpress</h3><pre><font face = "黑体" font size = 3>知识点一：Lambda表达式<br/>为解决匿名内部类代码冗余现象（不然要重写接口的方法），拷贝小括号、写死右箭头、落地大括号。<br/>知识点二：@FunctionalInterface<br/>该注释用于检查该接口是否为函数式接口。函数式接口一般只有一个输出，类似于函数f(x) = y。<br/>定义一个接口，其中只有方法声明，没有方法实现（java8之后允许有部分实现）<br/>接口中有且只有一个声明方法，就是函数式接口。<br/>知识点三：default<br/>在函数式接口中，可定义default方法，并且可定义多个。<br/>知识点四：static<br/>在函数式接口中，可定义static方法，并且可定义多个。<br/></pre><br>---<h3 id="Lesson-004-集合类不安全"><a href="#Lesson-004-集合类不安全" class="headerlink" title="Lesson 004 集合类不安全"></a>Lesson 004 集合类不安全</h3><table><thead><tr><th align="center">接口</th><th align="center">List</th><th align="center">Set</th><th align="center">Map</th></tr></thead><tbody><tr><td align="center">类</td><td align="center">ArrayList</td><td align="center">HashSet</td><td align="center">HashMap</td></tr><tr><td align="center">解决</td><td align="center">CopyOnWriteArrayList</td><td align="center">CopyOnWriteArraySet</td><td align="center">ConcurrentHashMap</td></tr><tr><td align="center">以上三种集合类都不安全。<br/></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">原因：多线程争抢同一资源类，没有加锁导致的。</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">故障现象：java.util.ConcurrentModificationException(并发修改异常)</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><pre><font face = "黑体" font size = 3>问题一：当我new了一个ArrayList,底层实际new了一个什么?<br/>答：ArrayList数据库为数组，数组元素为Object<br/>问题二：ArrayList的默认初始长度是多少？<br/>答：初始化一个长度为10的Object数组。HashMap的初始长度为16。<br/>问题三：ArrayList扩容多少？如何扩容？<br/>答：扩大一半：10 -> 15 -> 15 + [15 / 2] = 22。搬家过程：Array.copy()。HashMap扩大一倍。<br/>问题四：ArrayList线程安全吗？<br/>答：不安全。<br/>问题五：写一个ArrayList、HashMap、HashSet线程不安全的代码。<br/>    public static void main(String[] args) {        //List a = new ArrayList();                     // ArrayList线程不安全（效率第一）        List<String> a = new CopyOnWriteArrayList<>();        // 30个线程同时操作一个ArrayList        for (int i = 0; i <= 30; i++) {            new Thread(() -> {                a.add(UUID.randomUUID().toString().substring(0,8));                System.out.println(a);            }, String.valueOf(i)).start();        }    }    public static void main(String[] args) {        //Set a = new HashSet();                     // HashSet()线程不安全        Set<String> a = new CopyOnWriteArraySet<>();        // 30个线程同时操作一个ArrayList        for (int i = 0; i <= 30; i++) {            new Thread(() -> {                a.add(UUID.randomUUID().toString().substring(0,8));                System.out.println(a);            }, String.valueOf(i)).start();        }    }        public static void main(String[] args) {        // Map<String, String> map = new HashMap<>(); // HashMap线程也不安全        Map<String, String> map = new ConcurrentHashMap<>();        for (int i = 0; i <= 30; i++) {            new Thread(() -> {                map.put(UUID.randomUUID().toString().substring(0,2), UUID.randomUUID().toString().substring(0, 8));                System.out.println(map);            }, String.valueOf(i).toString()).start();        }    }问题六：Collection和Collections的区别？<br/>答：前者为接口(集合类的一个顶级接口)，后者为集合接口的包装类（工具类、帮助类），此类不能实例化，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。<br/>问题七：HashSet的底层结构？<br/>答：HashMap。<br/>问题八：HashSet在add操作时，只有一个参数，而HashMap在put()操作时却加入两个参数，一个是key，一个是value，它的底层结构真的是HashMap吗？<br/>答：真的是，public boolean add(E e){    return map.put(e, PRESENT) == null;    } # 加了一个Object类（PRESENT）作为value<br/>问题九：四大函数接口是什么？<br/>答：1.提供者（supplier）：不接受参数，但提供返回值(getter())    2.消费者（consumer）：接收一个参数，无返回值(foreach)    3.函数（function）：接收函数，输出结果    4.断言型（predicate）：用于判断操作，返回Boolean</pre><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><h3 id="lesson-006-八锁"><a href="#lesson-006-八锁" class="headerlink" title="lesson 006 八锁"></a>lesson 006 八锁</h3><pre><font face = "黑体" font size = 3>只要在同资源类中，不管有几个synchronized方法，只要一个线程先访问了资源类里的任一synchronized方法，那么它锁的是整个资源类，锁了这个对象this（**对象锁**），被锁定后，其他线程不能进入当前对象的synchronized方法。**某一时刻内，只有唯一线程访问对象的synchronized方法。<br/>**加个普通方法后，发现与同步锁无关。<br/>换成两个对象之后，就不是一把锁了。<br/>static修饰的方法，属于整个类，而非某个对象，static锁的是“**全局锁**”。<br/>synchronized同步的基础：java中的每个对象都可作为锁。① 对于普通同步方法，锁是当前对象this② 对于同步方法块，锁是synchronized括号里的配置对象。③ 对于静态同步方法类，锁是当前Class对象。<br/>当一个线程试图访问同步代码块时，它必须得到锁，退出或抛出异常时，要释放锁。即，若一个对象的非静态同步方法获取锁，该实例对象的其他非静态同步方法要等锁释放后，才能获取锁。但**别的对象的非静态同步方法，因为不是同一把锁，所以不必等待。**<br/>所有静态同步方法用的也是同一把锁——类对象本身。两把锁是不同的对象，故静态同步方法与非静态同步方法**无竞态条件**。但某静态同步方法获取锁后，其他静态同步方法要等待释放。</pre><h3 id="lesson-014-生产者消费者"><a href="#lesson-014-生产者消费者" class="headerlink" title="lesson 014 生产者消费者"></a>lesson 014 生产者消费者</h3>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
